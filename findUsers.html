// findUsers.js
// Enhanced user search and contact management functionality

class FindUsers {
    constructor() {
        this.currentSearchTerm = '';
        this.usersData = [];
        this.isLoading = false;
        this.debounceTimer = null;
        this.currentUser = null;
        this.init();
    }

    async init() {
        console.log('ðŸ” FindUsers initializing...');
        
        // Get current user
        if (Backend && Backend.getCurrentUser) {
            this.currentUser = Backend.getCurrentUser();
        }
        
        await this.attachEventListeners();
        console.log('âœ… FindUsers ready');
    }

    async attachEventListeners() {
        // User search input - use event delegation
        document.addEventListener('input', (e) => {
            if (e.target.id === 'userSearchInput') {
                this.currentSearchTerm = e.target.value.trim();
                this.debouncedSearch();
            }
        });

        // Close modal when clicking outside
        document.addEventListener('click', (event) => {
            const modal = document.getElementById('usersModal');
            if (event.target === modal) {
                this.hideUsers();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                const modal = document.getElementById('usersModal');
                if (modal.style.display === 'block') {
                    this.hideUsers();
                }
            }
        });

        // Global event listeners for action buttons
        document.addEventListener('click', (e) => {
            // Handle user action buttons
            if (e.target.closest('.user-action-btn.add')) {
                const userCard = e.target.closest('.user-result');
                if (userCard) {
                    const userId = userCard.dataset.userId;
                    const username = userCard.dataset.username;
                    if (userId && username) {
                        this.addContact(userId, username);
                    }
                }
            }
            
            if (e.target.closest('.user-action-btn.message')) {
                const userCard = e.target.closest('.user-result');
                if (userCard) {
                    const userId = userCard.dataset.userId;
                    const username = userCard.dataset.username;
                    if (userId && username) {
                        this.startChat(userId, username);
                    }
                }
            }
            
            if (e.target.closest('.user-action-btn.accept')) {
                const userCard = e.target.closest('.user-result');
                if (userCard) {
                    const contactId = userCard.dataset.contactId;
                    const username = userCard.dataset.username;
                    if (contactId && username) {
                        this.acceptRequest(contactId, username);
                    }
                }
            }
            
            if (e.target.closest('.user-action-btn.reject')) {
                const userCard = e.target.closest('.user-result');
                if (userCard) {
                    const contactId = userCard.dataset.contactId;
                    const username = userCard.dataset.username;
                    if (contactId && username) {
                        this.rejectRequest(contactId, username);
                    }
                }
            }
            
            if (e.target.closest('.user-action-btn.cancel')) {
                const userCard = e.target.closest('.user-result');
                if (userCard) {
                    const contactId = userCard.dataset.contactId;
                    const username = userCard.dataset.username;
                    if (contactId && username) {
                        this.cancelRequest(contactId, username);
                    }
                }
            }
        });
    }

    debouncedSearch() {
        clearTimeout(this.debounceTimer);
        this.debounceTimer = setTimeout(() => {
            this.loadUsers(this.currentSearchTerm);
        }, 300);
    }

    // =============== MODAL FUNCTIONS ===============
    
    // Show users modal
    async showUsers() {
        console.log('ðŸ‘¥ Showing users modal...');
        
        const modal = document.getElementById('usersModal');
        const searchInput = document.getElementById('userSearchInput');
        
        modal.style.display = 'block';
        this.currentSearchTerm = '';
        
        if (searchInput) {
            searchInput.value = '';
            setTimeout(() => searchInput.focus(), 100);
        }
        
        await this.loadUsers();
    }

    // Hide users modal
    hideUsers() {
        console.log('ðŸ‘‹ Hiding users modal');
        const modal = document.getElementById('usersModal');
        modal.style.display = 'none';
        this.currentSearchTerm = '';
    }

    // =============== USER LOADING FUNCTIONS ===============
    
    // Load users with search functionality
    async loadUsers(searchTerm = '') {
        if (this.isLoading) return;
        
        this.isLoading = true;
        const usersList = document.getElementById('usersList');
        
        try {
            // Show loading state
            usersList.innerHTML = this.createLoadingHTML();
            
            let result;
            
            // Try using Backend functions first
            if (typeof Backend.getUsersWithContactStatus === 'function') {
                console.log('Using Backend.getUsersWithContactStatus()');
                result = await Backend.getUsersWithContactStatus();
            } 
            // If Backend function fails or doesn't exist, try direct Parse query
            else {
                console.log('Using direct Parse query for User class');
                result = await this.queryParseUsersDirectly(searchTerm);
            }
            
            console.log('ðŸ“Š Users result:', result);
            
            if (result.success) {
                this.usersData = result.users || [];
                await this.displayUsers(this.usersData);
            } else {
                console.error('âŒ Failed to load users:', result.error);
                usersList.innerHTML = this.createErrorHTML(
                    'Error loading users',
                    result.error || 'Please try again'
                );
            }
        } catch (error) {
            console.error('âŒ Error in loadUsers:', error);
            usersList.innerHTML = this.createErrorHTML(
                'Connection Error',
                'Please check your connection and try again'
            );
            
            // Try alternative method
            try {
                console.log('Trying alternative user loading method...');
                const altResult = await this.queryParseUsersDirectly(searchTerm);
                if (altResult.success && altResult.users && altResult.users.length > 0) {
                    console.log('Alternative method found users:', altResult.users.length);
                    // Reload with alternative result
                    this.isLoading = false;
                    await this.loadUsers(searchTerm);
                    return;
                }
            } catch (altError) {
                console.error('Alternative method also failed:', altError);
            }
        } finally {
            this.isLoading = false;
        }
    }

    // Display users in the modal
    async displayUsers(users) {
        const usersList = document.getElementById('usersList');
        
        if (!users || users.length === 0) {
            const searchTerm = this.currentSearchTerm;
            usersList.innerHTML = this.createEmptyStateHTML(
                searchTerm ? 'No users found' : 'No users available',
                searchTerm ? 'Try a different search' : 'No other users are registered yet'
            );
            return;
        }

        // Get current user to avoid showing self
        if (!this.currentUser && Backend && Backend.getCurrentUser) {
            this.currentUser = Backend.getCurrentUser();
        }
        const currentUserId = this.currentUser ? this.currentUser.id : null;
        
        usersList.innerHTML = '';
        
        users.forEach(user => {
            // Skip current user
            if (user.id === currentUserId || user.objectId === currentUserId) return;
            
            const userElement = this.createUserElement(user);
            usersList.appendChild(userElement);
        });
        
        // If all users were filtered out (only current user exists)
        if (usersList.children.length === 0) {
            usersList.innerHTML = this.createEmptyStateHTML(
                'No other users',
                'You are the only user registered'
            );
        }
    }

    // =============== USER ELEMENT CREATION ===============
    
    // Create user element HTML
    createUserElement(user) {
        const userDiv = document.createElement('div');
        userDiv.className = 'user-result';
        
        const username = user.username || 'Unknown';
        const userId = user.id || user.objectId;
        const contactId = user.contactId;
        const isContact = user.isContact || false;
        const isPending = user.isPending || false;
        const sentByMe = user.sentByMe || false;
        
        // Set data attributes for event handling
        userDiv.dataset.userId = userId;
        userDiv.dataset.username = username;
        userDiv.dataset.contactId = contactId;
        userDiv.dataset.isContact = isContact;
        userDiv.dataset.isPending = isPending;
        userDiv.dataset.sentByMe = sentByMe;
        
        // Action buttons based on contact status
        let actionButtons = this.createActionButtonsHTML(
            isContact, 
            isPending, 
            sentByMe, 
            userId, 
            username, 
            contactId
        );
        
        userDiv.innerHTML = `
            <div class="user-result-avatar">
                ${username[0].toUpperCase()}
            </div>
            <div class="user-result-info">
                <div class="user-result-name">${this.escapeHTML(username)}</div>
                <div class="user-result-status">
                    ${this.getStatusText(user)}
                </div>
            </div>
            <div class="user-result-actions">
                ${actionButtons}
            </div>
        `;
        
        return userDiv;
    }

    // Create appropriate action buttons HTML
    createActionButtonsHTML(isContact, isPending, sentByMe, userId, username, contactId) {
        if (isContact) {
            return `
                <button class="user-action-btn friends" title="Already Friends">
                    <i class="fas fa-check"></i>
                </button>
                <button class="user-action-btn message" title="Message">
                    <i class="fas fa-comment"></i>
                </button>
            `;
        } else if (isPending) {
            if (sentByMe) {
                return `
                    <button class="user-action-btn pending" title="Request Sent">
                        <i class="fas fa-clock"></i>
                    </button>
                    <button class="user-action-btn cancel" title="Cancel Request">
                        <i class="fas fa-times"></i>
                    </button>
                `;
            } else {
                return `
                    <button class="user-action-btn accept" title="Accept Request">
                        <i class="fas fa-check"></i>
                    </button>
                    <button class="user-action-btn reject" title="Reject Request">
                        <i class="fas fa-times"></i>
                    </button>
                `;
            }
        } else {
            return `
                <button class="user-action-btn add" title="Add Contact">
                    <i class="fas fa-user-plus"></i>
                </button>
            `;
        }
    }

    // Get status text for user
    getStatusText(user) {
        if (user.isContact) {
            return 'Already friends';
        } else if (user.isPending) {
            if (user.sentByMe) {
                return 'Request sent';
            } else {
                return 'Request received';
            }
        } else {
            return 'Not connected';
        }
    }

    // Direct Parse query for User class
    queryParseUsersDirectly: async function(searchTerm = '') {
        try {
            console.log('ðŸ” Querying Parse User class directly...');
            
            const UserClass = Parse.Object.extend('User');
            const query = new Parse.Query(UserClass);
            
            // Exclude current user
            const currentUser = Parse.User.current();
            if (currentUser) {
                query.notEqualTo('objectId', currentUser.id);
            }
            
            // Apply search filter if provided
            if (searchTerm && searchTerm.length >= 1) {
                query.contains('username', searchTerm);
                query.contains('username', searchTerm.toLowerCase());
                query.contains('username', searchTerm.toUpperCase());
            }
            
            // Limit results
            query.limit(50);
            
            // Sort by username
            query.ascending('username');
            
            const users = await query.find();
            console.log(`âœ… Found ${users.length} users in Parse User class`);
            
            // Format users for display
            const formattedUsers = users.map(user => ({
                id: user.id,
                objectId: user.id,
                username: user.get('username') || 'Unknown',
                createdAt: user.createdAt,
                updatedAt: user.updatedAt
            }));
            
            return {
                success: true,
                users: formattedUsers
            };
            
        } catch (error) {
            console.error('âŒ Parse query error:', error);
            return {
                success: false,
                error: error.message || 'Failed to query users'
            };
        }
    },
    
    // Test Parse connection
    testParseConnection: async function() {
        console.log('ðŸ”§ Testing Parse connection...');
        try {
            const UserClass = Parse.Object.extend('User');
            const query = new Parse.Query(UserClass);
            query.limit(1);
            const testResult = await query.find();
            console.log(`âœ… Parse connection test: ${testResult.length > 0 ? 'SUCCESS - Found users' : 'SUCCESS - No users found'}`);
            return {
                success: true,
                count: testResult.length
            };
        } catch (error) {
            console.error('âŒ Parse connection test failed:', error);
            return {
                success: false,
                error: error.message
            };
        }
    },

    // =============== CONTACT ACTION FUNCTIONS ===============
    
    // Add contact
    async addContact(userId, username) {
        console.log(`âž• Adding contact: ${username} (${userId})`);
        
        try {
            showNotification('Sending contact request...', 'info', 2000);
            const result = await Backend.addContact(userId, username);
            
            if (result.success) {
                showNotification(`Contact request sent to ${username}! ðŸ“¤`, 'success');
                await this.loadUsers(this.currentSearchTerm);
                
                // Update sidebar requests badge
                this.updateRequestsBadge();
            } else {
                showNotification(result.error || 'Failed to send request', 'error');
            }
        } catch (error) {
            console.error('Add contact error:', error);
            showNotification('Failed to send contact request', 'error');
        }
    }

    // Accept contact request
    async acceptRequest(contactId, username) {
        console.log(`âœ… Accepting request from: ${username} (${contactId})`);
        
        try {
            const result = await Backend.acceptContact(contactId);
            
            if (result.success) {
                showNotification(`${username} added to contacts! ðŸ‘¥`, 'success');
                await this.loadUsers(this.currentSearchTerm);
                
                // Update sidebar contacts and requests
                this.updateSidebarData();
            } else {
                showNotification('Failed to accept request', 'error');
            }
        } catch (error) {
            console.error('Accept contact error:', error);
            showNotification('Failed to accept request', 'error');
        }
    }

    // Reject contact request
    async rejectRequest(contactId, username) {
        if (!confirm(`Reject contact request from ${username}?`)) return;
        
        console.log(`âŒ Rejecting request from: ${username} (${contactId})`);
        
        try {
            const result = await Backend.removeContact(contactId);
            
            if (result.success) {
                showNotification(`Request from ${username} rejected`, 'info');
                await this.loadUsers(this.currentSearchTerm);
                this.updateRequestsBadge();
            } else {
                showNotification('Failed to reject request', 'error');
            }
        } catch (error) {
            console.error('Reject contact error:', error);
            showNotification('Failed to reject request', 'error');
        }
    }

    // Cancel sent request
    async cancelRequest(contactId, username) {
        if (!confirm(`Cancel contact request to ${username}?`)) return;
        
        console.log(`ðŸš« Canceling request to: ${username} (${contactId})`);
        
        try {
            const result = await Backend.removeContact(contactId);
            
            if (result.success) {
                showNotification(`Request to ${username} cancelled`, 'info');
                await this.loadUsers(this.currentSearchTerm);
                this.updateRequestsBadge();
            } else {
                showNotification('Failed to cancel request', 'error');
            }
        } catch (error) {
            console.error('Cancel contact error:', error);
            showNotification('Failed to cancel request', 'error');
        }
    }

    // Start chat with user
    async startChat(userId, username) {
        console.log(`ðŸ’¬ Starting chat with: ${username} (${userId})`);
        
        this.hideUsers();
        
        // Call global startChat function if it exists
        if (typeof window.startChat === 'function') {
            window.startChat(userId, username);
        } else {
            // Fallback
            showNotification(`Starting chat with ${username}...`, 'info');
            
            // You might want to implement direct chat opening here
            if (typeof window.selectChat === 'function') {
                window.selectChat(userId, username);
            }
        }
    }

    // =============== SIDEBAR UPDATE FUNCTIONS ===============
    
    // Update sidebar data after contact actions
    async updateSidebarData() {
        try {
            // Update contacts tab
            if (typeof window.loadContacts === 'function') {
                await window.loadContacts();
            }
            
            // Update requests tab
            if (typeof window.loadRequests === 'function') {
                await window.loadRequests();
            }
            
            // Update chats tab
            if (typeof window.loadChats === 'function') {
                setTimeout(() => window.loadChats(), 500);
            }
            
            this.updateRequestsBadge();
        } catch (error) {
            console.error('Error updating sidebar:', error);
        }
    }

    // Update requests badge
    async updateRequestsBadge() {
        try {
            if (typeof window.loadRequests === 'function') {
                await window.loadRequests();
            }
        } catch (error) {
            console.error('Error updating badge:', error);
        }
    }

    // =============== UTILITY FUNCTIONS ===============
    
    // Escape HTML to prevent XSS
    escapeHTML(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Create loading HTML
    createLoadingHTML() {
        return `
            <div class="loading">
                <div class="spinner"></div>
                <span>Loading users...</span>
            </div>
        `;
    }

    // Create error HTML
    createErrorHTML(title, message) {
        return `
            <div class="empty-state">
                <i class="fas fa-exclamation-triangle"></i>
                <h3>${this.escapeHTML(title)}</h3>
                <p>${this.escapeHTML(message)}</p>
            </div>
        `;
    }

    // Create empty state HTML
    createEmptyStateHTML(title, message) {
        return `
            <div class="empty-state">
                <i class="fas fa-user-slash"></i>
                <h3>${this.escapeHTML(title)}</h3>
                <p>${this.escapeHTML(message)}</p>
            </div>
        `;
    }

    // =============== GLOBAL HELPER FUNCTIONS ===============
    
    // Show notification (fallback if not available globally)
    showNotification(message, type = 'info', duration = 4000) {
        if (typeof window.showNotification === 'function') {
            window.showNotification(message, type, duration);
        } else {
            // Fallback notification
            console.log(`[${type.toUpperCase()}] ${message}`);
            alert(`${type.toUpperCase()}: ${message}`);
        }
    }

    // Debug function
    debug() {
        console.log('ðŸ› DEBUG: Checking backend functions...');
        console.log('Backend available:', typeof Backend !== 'undefined');
        console.log('Backend functions:');
        console.log('- getUsersWithContactStatus:', typeof Backend.getUsersWithContactStatus);
        console.log('- searchUsers:', typeof Backend.searchUsers);
        console.log('- getCurrentUser:', typeof Backend.getCurrentUser);
        
        // Test current user
        const currentUser = Backend.getCurrentUser();
        console.log('Current user:', currentUser);
        if (currentUser) {
            console.log('Current user ID:', currentUser.id);
            console.log('Current username:', currentUser.get('username'));
        }
        
        // Test Parse directly
        this.testParseConnection();
    }
}

// =============== GLOBAL EXPORTS ===============

// Create global instance
let findUsers;

// Initialize when document is ready
document.addEventListener('DOMContentLoaded', () => {
    findUsers = new FindUsers();
    
    // Expose methods to global scope
    window.showUsers = () => findUsers.showUsers();
    window.hideUsers = () => findUsers.hideUsers();
    window.searchUsers = () => findUsers.loadUsers(document.getElementById('userSearchInput')?.value || '');
    
    // Expose action functions for backward compatibility
    window.addContact = (userId, username) => findUsers.addContact(userId, username);
    window.acceptContactRequest = (contactId, username) => findUsers.acceptRequest(contactId, username);
    window.rejectContactRequest = (contactId, username) => findUsers.rejectRequest(contactId, username);
    window.cancelContactRequest = (contactId, username) => findUsers.cancelRequest(contactId, username);
    window.startChatFromUsers = (userId, username) => findUsers.startChat(userId, username);
    window.acceptFromUsers = (contactId, username) => findUsers.acceptRequest(contactId, username);
});

// Expose for manual initialization
window.FindUsers = FindUsers;

// Make sure it's available immediately for inline onclick handlers
if (typeof window !== 'undefined') {
    // Create placeholder functions that will be replaced when DOM is ready
    window.showUsers = function() {
        console.warn('FindUsers not initialized yet. Please wait for DOMContentLoaded.');
    };
    window.hideUsers = function() {
        console.warn('FindUsers not initialized yet. Please wait for DOMContentLoaded.');
    };
}
